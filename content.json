{"meta":{"title":"大白菜","subtitle":"","description":"","author":"Shixiong Zhan","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"java-base-threadlocal","slug":"java-base-threadlocal","date":"2021-01-06T03:40:13.000Z","updated":"2021-01-06T03:40:56.345Z","comments":true,"path":"2021/01/06/java-base-threadlocal/","link":"","permalink":"http://example.com/2021/01/06/java-base-threadlocal/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"java-base-reference","slug":"java-base-reference","date":"2021-01-06T01:38:30.000Z","updated":"2021-01-07T15:14:22.340Z","comments":true,"path":"2021/01/06/java-base-reference/","link":"","permalink":"http://example.com/2021/01/06/java-base-reference/","excerpt":"Java对象引用的4个级别：强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用","text":"Java对象引用的4个级别：强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用 强引用：强引用存在时，对象就不会被GC回收掉，Jvm宁愿抛出OOM异常，也不会在GC时回收掉该对象。 测试代码： 123456789101112131415161718192021222324byte[] arr &#x3D; null;byte[] arr2 &#x3D; null;try &#123; arr &#x3D; new byte[1024 * 1024 * 12]; &#x2F;&#x2F; arr：(有值) System.out.println(&quot;arr new: &quot; + arr); &#x2F;&#x2F; 通知jvm gc System.gc(); &#x2F;&#x2F; 这里睡2s是为了保证gc能执行完成 Thread.sleep(2000); &#x2F;&#x2F; arr：gc是不能直接回收的，(有值) System.out.println(&quot;arr after gc: &quot; + arr); &#x2F;&#x2F; 设置最大堆空间为20M，这个会由于申请不到内存直接OOM arr2 &#x3D; new byte[1024 * 1024 * 12]; &#x2F;&#x2F; arr2：(无法输出) System.out.println(&quot;arr2 new: &quot; + arr2);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; &#x2F;&#x2F; arr：gc没有回收，(有值) System.out.println(&quot;arr final: &quot; + arr); &#x2F;&#x2F; arr2：申请不到内存，(无值) System.out.println(&quot;arr2 final: &quot; + arr2);&#125; 输出结果： 123456arr new: [B@1b6d3586arr after gc: [B@1b6d3586arr final: [B@1b6d3586arr2 final: nullException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at com.zsx.base.reference.NormalReference.main(NormalReference.java:22) 从输出结果可以看出，强引用对象在引用存在时，gc是不会回收的；当内存不足时，gc也不会强制回收，而是宁愿抛出OOM异常。这里说明一下：输出中**[B1b6d3586**的含义是=&gt; [：表示数组，B：表示Byte类型，1b6d3586：对象的hash值。 软引用软引用存在时，在内存充足时，不会被gc回收掉，当内存不足时，会被gc回收。 测试代码： 123456789101112131415161718192021222324SoftReference&lt;byte[]&gt; arr &#x3D; null;byte[] arr2 &#x3D; null;try &#123; arr &#x3D; new SoftReference&lt;byte[]&gt;(new byte[1024 * 1024 * 12]); &#x2F;&#x2F; arr：(有值) System.out.println(&quot;arr new: &quot; + arr.get()); &#x2F;&#x2F; 通知jvm gc System.gc(); &#x2F;&#x2F; 这里睡2s是为了保证gc能执行完成 Thread.sleep(2000); &#x2F;&#x2F; arr：gc是不能直接回收的，(有值) System.out.println(&quot;arr after gc: &quot; + arr.get()); &#x2F;&#x2F; 设置最大堆空间为20M，这个会由于内存不足，然后触发gc回收掉软引用arr arr2 &#x3D; new byte[1024 * 1024 * 12]; &#x2F;&#x2F; arr2：(有值) System.out.println(&quot;arr2 new: &quot; + arr2);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; &#x2F;&#x2F; arr：gc已强制回收，(无值) System.out.println(&quot;arr final: &quot; + arr.get()); &#x2F;&#x2F; arr2：gc回收了arr，new了arr2(有值) System.out.println(&quot;arr2 final: &quot; + arr2);&#125; 输出结果： 12345arr new: [B@1b6d3586arr after gc: [B@1b6d3586arr2 new: [B@4554617carr final: nullarr2 final: [B@4554617c 从输出结果可以看出，软引用在引用存在时，只有当内存充足时，才不会被gc回收，否则当内存不足时，gc会强制回收软引用对象占用的空间。 弱引用弱引用存在时，只要触发了gc，弱引用对象就会被强制回收，无论此时jvm内存空间是否充足。 测试代码： 123456789101112131415161718192021222324WeakReference&lt;byte[]&gt; arr &#x3D; null;byte[] arr2 &#x3D; null;try &#123; arr &#x3D; new WeakReference&lt;byte[]&gt;(new byte[1024 * 1024 * 12]); &#x2F;&#x2F; arr：(有值) System.out.println(&quot;arr new: &quot; + arr.get()); &#x2F;&#x2F; 通知jvm gc System.gc(); &#x2F;&#x2F; 这里睡2s是为了保证gc能执行完成 Thread.sleep(2000); &#x2F;&#x2F; arr：gc直接回收，(无值) System.out.println(&quot;arr after gc: &quot; + arr.get()); &#x2F;&#x2F; 没有啥限制了 arr2 &#x3D; new byte[1024 * 1024 * 12]; &#x2F;&#x2F; arr2：(有值) System.out.println(&quot;arr2 new: &quot; + arr2);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; &#x2F;&#x2F; arr：gc已回收，(无值) System.out.println(&quot;arr final: &quot; + arr.get()); &#x2F;&#x2F; arr2：(有值) System.out.println(&quot;arr2 final: &quot; + arr2);&#125; 输出结果： 12345arr new: [B@1b6d3586arr after gc: nullarr2 new: [B@4554617carr final: nullarr2 final: [B@4554617c 从输出结果可以看出，弱引用在引用存在时，只要触发了gc，弱引用就会被gc回收掉。 虚引用虚引用存在时，一般由堆外内存控制虚引用，类似directBuffer，待验证。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-04T13:53:45.490Z","updated":"2021-01-04T13:53:45.490Z","comments":true,"path":"2021/01/04/hello-world/","link":"","permalink":"http://example.com/2021/01/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}